import time
import json

from block_handler import received_blocks, header_store, create_getblock, get_block_by_id
from peer_discovery import peer_config, known_peers
from utils import generate_message_id
from outbox import gossip_message, enqueue_message


def create_inv(sender_id, block_ids):
    # TODO: * Define the JSON format of an `INV` message, which should include `{message type, sender's ID, sending blocks' IDs, message ID}`.
    # Note that `INV` messages are sent before sending blocks. 
    # `sending blocks' IDs` is the ID of blocks that the sender want to send. 
    # `message ID` can be a random number generated by `generate_message_id` in `util.py`.
    """创建INV（库存）消息"""
    return {
        "type": "INV",
        "sender": sender_id,
        "block_ids": block_ids,
        "message_id": generate_message_id()
    }


def get_inventory(self_id):
    # TODO: Return the block ID of all blocks in the local blockchain.
    """获取本地库存（所有区块ID）"""
    node_config = peer_config.get(self_id, {})
    # 轻节点只返回区块头哈希
    if node_config.get("light", False):
        return [header["hash"] for header in header_store]
    # 全节点返回完整区块哈希
    return [block.hash for block in received_blocks]

def broadcast_inventory(self_id):
    # TODO: Create an `INV` message with all block IDs in the local blockchain.

    # TODO: Broadcast the `INV` message to known peers using the function `gossip_message` in `outbox.py` to synchronize the blockchain with known peers.
    """广播库存消息同步区块链"""
    try:
        # 获取本地库存
        inventory = get_inventory(self_id)
        if len(inventory)>10:
            choose_inventory = inventory[-10:-1]
            inv_msg = create_inv(str(self_id), choose_inventory)
        else:
            inv_msg = create_inv(str(self_id), inventory)
        # 广播给所有已知节点
        print(f"[{self_id}] Broadcasting inventory: {len(inventory)} blocks", flush=True)
        gossip_message(str(self_id), inv_msg)

    except Exception as e:
        print(f"[{self_id}] Inventory broadcast error: {e}", flush=True)


def handle_inv(msg, self_id):
    """处理INV消息（在message_handler中调用）"""
    try:
        sender_id = msg["sender"]
        received_ids = set(msg["block_ids"])

        # 获取本地库存
        local_ids = set(get_inventory(self_id))

        # 找出缺失的区块ID
        missing_ids = received_ids - local_ids

        if missing_ids:
            print(f"[{self_id}] Requesting {len(missing_ids)} missing blocks from {sender_id}", flush=True)
            # 创建GETBLOCK消息
            getblock_msg = create_getblock(self_id, list(missing_ids))

            # 发送请求
            ip, port = known_peers[sender_id]
            enqueue_message(sender_id, ip, port, getblock_msg)

    except Exception as e:
        print(f"[{self_id}] INV handling error: {e}", flush=True)


def handle_getblock(msg, self_id):
    """处理GETBLOCK请求（在message_handler中调用）"""
    try:
        sender_id = msg["sender"]
        requested_ids = msg["requested_ids"]

        # 获取请求的区块
        blocks = []
        for block_id in requested_ids:
            block = get_block_by_id(block_id)
            if block:
                # 轻节点只发送区块头
                if peer_config[self_id].get("light", False):
                    block_data = {
                        "hash": block.hash,
                        "prev_hash": block.prev_hash,
                        "timestamp": block.timestamp
                    }
                else:
                    block_data = block.to_dict()
                blocks.append(block_data)

        if blocks:
            # 发送区块
            for block in blocks:
                enqueue_message(sender_id, *known_peers[sender_id], block)

    except Exception as e:
        print(f"[{self_id}] GETBLOCK handling error: {e}", flush=True)
